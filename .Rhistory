dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
B = 0.2 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, t=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, t=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
B = 2 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, t=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#######################################################################################
#Loading packages
library(deSolve)
library(ggplot2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, t=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#######################################################################################
#Loading packages
library(deSolve)
library(ggplot2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, t=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+t))*s + b*(s/(s+(w*t)+r))*t - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(t/((w*s)+t))*s + b*(w*t/(s+(w*t)+r))*t + b*(t/(t+(w*r)))*r - d*t - B*t(is+it)
dIt = B*t(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*t)+r))*t + b*(w*r/(t+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to(is+it)
dIt = B*to(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 2 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#######################################################################################
#Loading packages
library(deSolve)
library(ggplot2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.3 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 200, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 2 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.5 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.3 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#######################################################################################
#Loading packages
library(deSolve)
library(ggplot2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.7 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Here, S=red, Is=orange, t=yellow, =green, and r=blue (rainbow order)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.1 #infection rate
D = 0.7 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
D = 0.5 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.5 #infection rate
D = 0.5 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s + b*(s/(s+(w*to)+r))*to - d*s - B*s*(is+it)
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)+r))*to + b*(to/(to+(w*r)))*r - d*to - B*to*(is+it)
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/(s+(w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.5 #infection rate
D = 0.5 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s - d*s - B*s*(is+it) # + b*(s/(s+(w*to)+r))*to
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)))*to - d*to - B*to*(is+it) #+ b*(to/(to+(w*r)))*r
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/((w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
#Defining parameters
b = 0.1 #birth rate
d = 0.1 #natural death rate
B = 0.5 #infection rate
D = 0.5 #death rate due to DED
f = 0.5 #scaling factor for death due to DED
w = 1 #factor for biasing the births of each category to themselves
N = c(s=0.5, is=0.05, to=0.2, it=0.05, r=0.2) #initial population proportions
#Defining the equations in this function
str_model = function(t, N, params) {
with(as.list(N), {
dS = b*(w*s/((w*s)+to))*s - d*s - B*s*(is+it) # + b*(s/(s+(w*to)+r))*to
dIs = B*s*(is+it) - D*is #- d*is
dT = b*(to/((w*s)+to))*s + b*(w*to/(s+(w*to)))*to - d*to - B*to*(is+it) #+ b*(to/(to+(w*r)))*r
dIt = B*to*(is+it) - f*D*it #- d*it
dR = b*(r/((w*to)+r))*to + b*(w*r/(to+(w*r)))*r - d*r
list(c(dS, dIs, dT, dIt, dR))
})
}
#defining times to calculate solution
times = seq(1, 150, 0.2)
#calculating solutions
sol = ode(y=N, times = times, func = str_model)
matplot(x = sol[,1], y = sol[,-1], type = "l", lwd = 2, lty = c("solid"), col = c("red", "orange", "yellow", "green", "blue"), xlab = "time", ylab = "Population", ylim = c(-0.1,1))
abline(0,0, lty=2)
